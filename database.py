# --- Module Import -----------------------------
import os
import sqlite3

import configuration
import service

"""
Database Module
---------------
This file is for connecting the database, update database, reset database.
100% about doing any transaction with database.

If you want to create a transaction that created from action, use Transaction module
"""


def connect():
    """ Connect the database

    Using the SQLite, the database is stored locally.
    """
    # Open the database
    try:
        global DATABASE
        DATABASE = sqlite3.connect(configuration.CONFIG['database_path'])

        global DATABASE_CURSOR
        DATABASE_CURSOR = DATABASE.cursor()
    except Exception as inst:
        service.error(inst)


def initiate():
    """ Generate a new brand new table (database)

    Generally for starting the new game.
    """
    # Make sure the database is cleansed
    reset()
    # Open the database
    connect()

    if not os.path.exists(configuration.CONFIG['database_path']):
        service.error("There is no game.sqlite in {}".format(
            configuration.CONFIG['database_path']))

    create(configuration.CONFIG['database_create_file'])


def create(database_file_list: list):
    """ Create a database to the game.sql

    Args:
        database_file_list:
    """
    # Create database using pre-created CREATE script
    for j in database_file_list:

        service.log("Loading database file : {}".format(j))
        script = ""

        try:
            with open("config/database/{}".format(j)) as sql_script:
                for i in sql_script:

                    if i.find("--") == -1:
                        script += "{}\n".format(i)
            sql_script.close()  # Close file
        except BaseException as inst:
            service.error(inst)

        # service.log(script)

        try:
            DATABASE.execute(script)

        except sqlite3.ProgrammingError as inst:
            service.warning("Table may exist : " + str(inst))
            DATABASE.rollback()

        except sqlite3.Error as inst:
            service.warning("Table cannot be generated by unknown cause : " + str(inst))
            DATABASE.rollback()

        finally:
            DATABASE.commit()

    # make sure the database change is closed.
    DATABASE.close()


def describe(table_name):
    """
    Args:
        table_name:

    """
    # connect()
    #
    # try:
    #     DATABASE.execute("SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = {}".format(table_name))
    # except sqlite3.Error as inst:
    #     service.error(inst)
    #     DATABASE.rollback()
    # finally:
    #     DATABASE.commit()
    #
    # DATABASE.close()


def select(column: str, table: str, row: str = None, operator: str = None, quantity: str = None, fetch=False):
    # Open the database
    """ Create a SELECT script on database

    SELECT <column> FROM <table> WHERE <row> <operator> <quantity>

    Args:
        column:
        table:
        row:
        operator:
        quantity:
        fetch:
    """
    connect()

    try:
        if row is None or operator is None or quantity is None:
            # Make SELECT without WHERE keyword
            DATABASE.execute("SELECT {} FROM {}".format(column, table))

        else:
            # Make full SELECT with WHERE keyword
            DATABASE.execute("SELECT {} FROM {} WHERE {} {} {};".format(
                column, table, row, operator, quantity))

        if fetch:
            return DATABASE_CURSOR.fetchall()

    except sqlite3.Error as inst:
        raise inst

    # Close the database
    DATABASE.close()


def update(table_name, column, operator, column_quantity,
           where_column, where_column_value):
    """ Do an UPDATE script on database

    UPDATE <table_name> SET <column> <operator> <column_quantity> WHERE <where_column> = <where_column_value>

    Args:
        table_name :
        column :
        operator :
        column_quantity :
        where_column :
        where_column_value :

    Return:
        none

    Raise:
        none
    """
    # Open the database
    connect()

    # Make transaction on UPDATE
    try:
        sql_script = "UPDATE {} SET {} {} {} WHERE {} = {};".format(table_name, column, operator, column_quantity,
                                                                    where_column, where_column_value)
        DATABASE.execute(sql_script)

    except Exception as inst:
        DATABASE.rollback()
        service.error(inst)

    finally:
        DATABASE.commit()

    DATABASE.close()


def insert(table_name: str, values: list):
    """ Do an INSERT script on database

    INSERT INTO <table_name> VALUES (<values>);

    Args:
        values:
        table_name:

    Return:
        none

    Raise:
        none
    """
    # Open the database
    connect()

    # Change the values of list into a string
    values = str(values).lstrip('[').rstrip(']')

    # Execute a SQL command
    try:
        sql_script = "INSERT INTO {} VALUES ({})".format(table_name, values)

        DATABASE.execute(sql_script)

        service.log("Execute SQL : {}".format(sql_script))
    except Exception as inst:
        DATABASE.rollback()
        service.error(inst)
    finally:
        DATABASE.commit()

    DATABASE.close()


def exists(table_name, column, entry):
    # Open the database
    connect()

    try:
        sql_script = "SELECT * FROM {} WHERE {} = {}".format(table_name, column, entry)
        DATABASE.execute(sql_script)

    except sqlite3.OperationalError:
        return False

    except Exception as inst:
        DATABASE.rollback()
        service.error(inst)

    DATABASE.close()
    return True


def reset():
    """ Reset the database to make it newly generated

    NOTE: This function will be called during the game initiation.
    """
    service.log("Resetting the database")
    # Open the database
    connect()

    try:
        # Delete the old database file
        os.remove(configuration.CONFIG['database_path'])

        # Create the new database file
        file = open(configuration.CONFIG['database_path'], 'w+')
        file.close()

    except Exception as inst:
        # Rollback the change
        service.error(inst)
